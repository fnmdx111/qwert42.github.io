<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>qwert42</title>
    <link href="http://qwert42.github.io/feed/" rel="self" />
    <link href="http://webfrogs.github.com" />
    <lastBuildDate>2016-01-30T03:33:56-05:00</lastBuildDate>
    <webMaster>ccf.developer@gmail.com</webMaster>
    
    <item>
      <title>Solutions to exercises in Typeclassopedia</title>
      <link href="http://qwert42.github.io/2016/01/26/solutions-to-exercises-in-typeclassopedia/"/>
      <pubDate>2016-01-26T00:00:00-05:00</pubDate>
      <author>qwert42</author>
      <guid>http://qwert42.github.io/2016/01/26/solutions-to-exercises-in-typeclassopedia</guid>
      <content:encoded><![CDATA[<p>最近在重新学习Haskell，看完LYAHFGG之后，想加深一下对Applicative，Monad啥的理解，找了这个叫Typeclassopedia的文章来看。断断续续看了两个星期左右，把里面的习题也做得差不多了。下面列一下题解（不保证完全，也不保证正确）。</p>

<h2>Functor 函子</h2>

<p>要为一个类型<code>f</code>实现一个函子实例，这个类型必须具有<code>* -&gt; *</code>这样的kind。也就是说<code>f</code>必须再接受一个类型<code>a</code>才能成为一个完整的类型。而函子的<code>fmap</code>就是一个将<code>a</code>映射到另外一个类型<code>b</code>的映射。所以<code>fmap</code>具有这样的类型签名：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div>
<h3>实现<code>Either e</code>与<code>((-&gt;) e)</code>的函子实例</h3>

<p>首先我们知道<code>Either l r</code>是一个完整的类型（即<code>Either</code>的kind是<code>* -&gt; * -&gt; *</code>），那么要实现关于<code>Either</code>的函子实例，必须固定最左侧的<code>*</code>，也就是说我们只能实现关于<code>Either l</code>的函子实例。更具体来说，我们实现的函子实例可以将<code>Either l a</code>变换为<code>Either l b</code>。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">MyEither</span> <span class="o">=</span> <span class="kt">MyLeft</span> <span class="n">e</span> <span class="o">|</span> <span class="kt">MyRight</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">MyEither</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">_</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">MyLeft</span> <span class="n">e</span> <span class="o">=</span> <span class="kt">MyLeft</span> <span class="n">e</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">MyRight</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MyRight</span> <span class="o">$</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div>
<p>同样的道理<code>((-&gt;) e)</code>的函子实例可以将<code>(e -&gt; a)</code>映射为<code>(e -&gt; b)</code>，那么它的实现就很直观了。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div>
<p>如果要写得吊一点：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>
</code></pre></div>
<h3>实现<code>((,) e)</code>和<code>data Pair a = Pair a a</code>的函子实例，并解释他们的异同</h3>

<p>与上面一样，<code>(,)</code>的kind是<code>* -&gt; * -&gt; *</code>，那么只能实现<code>((,) e)</code>的函子实例，也就是说只能实现<code>(e, a)</code>到<code>(e, b)</code>的映射，而Pair的kind已经是<code>* -&gt; *</code>了，所以可以实现<code>Pair a a</code>到<code>Pair b b</code>的函子实例。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">newtype</span> <span class="kt">MyTuple</span> <span class="n">e</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MyTuple</span> <span class="p">{</span> <span class="n">getMyTuple</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">MyTuple</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">MyTuple</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="kt">MyTuple</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>


<span class="kr">data</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Pair</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<h3>实现以下类型的函子实例</h3>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">ITree</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Leaf</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
             <span class="o">|</span> <span class="kt">Node</span> <span class="p">[</span><span class="kt">ITree</span> <span class="n">a</span><span class="p">]</span>
</code></pre></div>
<p>Trivial:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">ITree</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">Leaf</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">Leaf</span> <span class="o">$</span> <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">t</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">Node</span> <span class="n">xs</span> <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div>
<p>*如果你知道<code>[]</code>也是一个函子，那么<code>map</code>实际上可以写成<code>fmap</code>。</p>

<h3>说明两个函子的复合也是一个函子</h3>

<p>首先定义出两个函子的复合这个类型，要注意<code>FCompose</code>这个构造器是一个一元函数，而不是三元函数：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">FCompose</span> <span class="n">f1</span> <span class="n">f2</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">FCompose</span> <span class="p">(</span><span class="n">f1</span> <span class="p">(</span><span class="n">f2</span> <span class="n">x</span><span class="p">))</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>
</code></pre></div>
<p>当<code>f1</code>和<code>f2</code>是函子时，</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f1</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">f2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">FCompose</span> <span class="n">f1</span> <span class="n">f2</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">FCompose</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">FCompose</span> <span class="o">$</span> <span class="n">fmap</span> <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">t</span>
  <span class="c1">-- = FCompose $ fmap (fmap f) t = FCompose $ (fmap . fmap) f t</span>
</code></pre></div>
<p>对于<code>FCompose f1 f2</code>，如果，<code>fmap</code>方法的类型应该是</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f1</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">f2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">FCompose</span> <span class="n">f1</span> <span class="n">f2</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">FCompose</span> <span class="n">f1</span> <span class="n">f2</span> <span class="n">b</span>
</code></pre></div>
<p>也就是说如果我们能把<code>f :: a -&gt; b</code>映射到<code>f1 (f2 a)</code>上并得到<code>f1 (f2 b)</code>，那么两个函子的复合就仍是一个函子。所以，</p>

<ol>
<li>首先利用<code>fmap :: (a -&gt; b) -&gt; f2 a -&gt; f2 b</code>把<code>f :: a -&gt; b</code>提升（lift）到<code>f2</code>上得到<code>f&#39; :: f2 a -&gt; f2 b</code>（柯里化）；</li>
<li>这样就可以用<code>f1</code>的<code>fmap :: (f2 a -&gt; f2 b) -&gt; f1 (f2 a) -&gt; f1 (f2 b)</code>将<code>f&#39;</code>提升为<code>f&#39;&#39; :: f1 (f2 a) -&gt; f1 (f2 b)</code>（仍然是柯里化）；</li>
<li>接下来将<code>f&#39;&#39;</code>应用到<code>f1 (f2 a)</code>上得到<code>f1 (f2 b)</code>。</li>
</ol>

<p>这说明两个任意函子的复合确实仍然是一个函子。它告诉我们，我们可以利用各种函子复合出任意复杂的新函子。</p>

<p>实际上，函数式编程的一个重要的部分就是利用各种复杂结构间的复合，降低整个程序的复杂度，即尽量将程序的复杂度转移到结构之中，由于结构是通用的，并且充分研究过的，使得程序员可以更加关注于问题的业务上的解决。也就是说，Typeclassopedia这篇文章里介绍的各种数据类型其实就是函数式编程中的<strong>设计模式</strong>。</p>

<p>要得到关于多个函子的复合的<code>fmap</code>方法，只需要将多个<code>fmap</code>复合。例如两个函子复合的情况，可以是<code>(fmap . fmap) f t</code>。</p>

<h2>Applicative 应用函子</h2>

<h3>证明以下等式</h3>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="o">$</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">f</span>
</code></pre></div>
<p>从右边入手</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">pure</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="o">$</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">f</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="o">$</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x'</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">f</span> <span class="kr">where</span> <span class="n">x</span> <span class="o">=</span> <span class="n">pure</span> <span class="n">x'</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="n">x'</span> <span class="n">f</span><span class="p">)</span>  <span class="c1">-- (Applicative的同态性)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x'</span><span class="p">)</span>  <span class="c1">-- (f $ y = f y)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x'</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span>
</code></pre></div>
<p>其实仔细看了之后会发现这个等式其实很无聊。</p>

<h3>实现<code>Maybe</code>的Applicative实例</h3>

<p>Trivial:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">MyMaybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">MyNothing</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">MyMaybe</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">MyJust</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">MyJust</span> <span class="o">$</span> <span class="n">f</span> <span class="n">x</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">MyNothing</span> <span class="o">=</span> <span class="kt">MyNothing</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">MyMaybe</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">x</span>
  <span class="kt">MyJust</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span>
  <span class="kt">MyNothing</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">MyNothing</span>
</code></pre></div>
<p>我们接下来来检查上面的实现是否满足Applicative的规定。</p>

<p>恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="kt">MyJust</span> <span class="mi">42</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="kt">MyJust</span> <span class="mi">42</span>
  <span class="o">=</span> <span class="n">fmap</span> <span class="n">id</span> <span class="p">(</span><span class="kt">MyJust</span> <span class="mi">42</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="p">(</span><span class="n">id</span> <span class="mi">42</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="mi">42</span>

    <span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="kt">MyNothing</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="kt">MyNothing</span>
  <span class="o">=</span> <span class="n">fmap</span> <span class="n">id</span> <span class="kt">MyNothing</span>
  <span class="o">=</span> <span class="kt">MyNothing</span>
</code></pre></div>
<p>同态律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="kt">MyJust</span> <span class="n">x</span>
  <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">MyJust</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div>
<p>交换律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="c1">-- 若 u = MyJust u'，</span>
    <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">u'</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="n">u'</span> <span class="o">&lt;*&gt;</span> <span class="kt">MyJust</span> <span class="n">y</span>
  <span class="o">=</span> <span class="n">fmap</span> <span class="n">u'</span> <span class="p">(</span><span class="kt">MyJust</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">MyJust</span> <span class="p">(</span><span class="n">u'</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">u'</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">u'</span> <span class="o">$</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">((</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="n">u'</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">((</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="n">u'</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">u'</span>  <span class="c1">-- 由同态律得</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>

<span class="c1">-- 若 u = MyNothing</span>
    <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span>
  <span class="o">=</span> <span class="kt">MyNothing</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span>
  <span class="o">=</span> <span class="kt">MyNothing</span>

    <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>
  <span class="o">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="kt">MyNothing</span>
  <span class="o">=</span> <span class="kt">MyNothing</span>

<span class="c1">-- =&gt; u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</span>
</code></pre></div>
<p>复合律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">v'</span> <span class="o">&lt;*&gt;</span> <span class="kt">Maybe</span> <span class="n">w'</span><span class="p">)</span>  <span class="c1">-- 由(&lt;*&gt;)的定义得</span>
  <span class="o">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">v'</span> <span class="n">w'</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="n">u'</span> <span class="o">&lt;*&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">v'</span> <span class="n">w'</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">u'</span> <span class="p">(</span><span class="n">v'</span> <span class="n">w'</span><span class="p">))</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">((</span><span class="n">u'</span> <span class="o">.</span> <span class="n">v'</span><span class="p">)</span> <span class="n">w'</span><span class="p">)</span>  <span class="c1">-- 由(.)的定义得</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">((</span><span class="o">.</span><span class="p">)</span> <span class="n">u'</span> <span class="n">v'</span> <span class="n">w'</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">((</span><span class="o">.</span><span class="p">)</span> <span class="n">u'</span> <span class="n">v'</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Maybe</span> <span class="n">w'</span>  <span class="c1">-- 由同态律得</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">((</span><span class="o">.</span><span class="p">)</span> <span class="n">u'</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Maybe</span> <span class="n">v'</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span>  <span class="c1">-- 仍然由同态律得</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Maybe</span> <span class="n">u'</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span>
  <span class="o">=</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span>
</code></pre></div>
<h3>确定<code>ZipList</code>的Applicative实例里<code>pure</code>的正确定义，能够满足Applicative性质的实现有且仅有一个</h3>

<p>我们已经知道<code>(&lt;*&gt;)</code>是使用<code>zipWith</code>函数实现的，现在考虑第一条性质<code>pure id &lt;*&gt; v = v</code>，如果<code>v</code>是一个有3个元素的<code>ZipList</code>，那么<code>pure id</code>就应该返回一个有<strong>至少</strong>三个<code>id</code>的<code>ZipList</code>，使得<code>zipWith</code>函数能够将<code>v</code>中的元素全部利用起来。到这里我们可以很轻松的得出<code>pure</code>的定义了</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="o">=</span> <span class="kt">ZipList</span> <span class="o">.</span> <span class="n">repeat</span>
</code></pre></div>
<p>我们稍微检查一下这个实现的性质：</p>

<p>恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">xs</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">id</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">xs</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">id</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="n">xs</span>  <span class="c1">-- 由Haskell常识得</span>
</code></pre></div>
<p>同态律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">x</span><span class="p">))</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="p">(</span><span class="n">f</span> <span class="o">$</span> <span class="n">x</span><span class="p">))</span>  <span class="c1">-- 由Haskell常识得</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))</span>
  <span class="o">=</span> <span class="kt">ZipList</span> <span class="o">.</span> <span class="n">repeat</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>  <span class="c1">-- 由(.)的定义得</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div>
<p>剩下的规则就不一一推导了。</p>

<h3>利用<code>unit</code>和<code>(**)</code>实现<code>pure</code>与<code>(&lt;*&gt;)</code>，再反过来实现他们</h3>

<p>考虑在这个情况下的<code>pure</code>、<code>unit</code>、<code>(**)</code>和<code>fmap</code>的类型签名（已知一个Monoidal是一个函子）：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">unit</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="p">(</span><span class="o">**</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">fmap</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></div>
<p>可以发现<code>fmap</code>的返回值类型就是我们关心的类型（<code>fmap</code>的返回值类型与<code>pure</code>的相同）。但是此时<code>fmap</code>中的<code>t</code>从哪来呢。这时我们可以注意到Monoidal的<code>unit</code>方法恒定返回一个<code>m ()</code>类型的值，那么如果将<code>t</code>特化成<code>()</code>，就有了</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></div>
<p>这样就清楚了，先构造出一个接受一个任意参数的函数，然后将这个函数<code>fmap</code>到<code>unit</code>上</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">unit</span>
<span class="c1">-- or</span>
<span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">const</span> <span class="n">x</span><span class="p">)</span> <span class="n">unit</span>
</code></pre></div>
<p>再考虑<code>(&lt;*&gt;)</code>与其它已知方法的类型签名：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="o">???</span>

<span class="n">unit</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="p">(</span><span class="o">**</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">fmap</span> <span class="o">::</span> <span class="kt">Monoidal</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div>
<p>可以发现<code>(&lt;*&gt;)</code>与<code>fmap</code>除了第一个参数类型不是特别相同，其它的是一样的。所以思路仍然是构造出一个供<code>fmap</code>使用的函数。同时我们发现<code>(**)</code>是Monoidal中可以与两个类型交互的方法，说明我们在构造上面说的函数中会使用到它。现在，已知量是<code>f :: m (a -&gt; b)</code>，<code>x :: m a</code>，我们首先可以尝试<code>f ** x</code>，这样我们会得到<code>f ** x :: m (a -&gt; b, a)</code>，而这样的类型很容易让人联想到它的计算结果的类型就是<code>m b</code>！因此如果将<code>fmap</code>中的<code>m a</code>特化成<code>m (a -&gt; b, a)</code>，那么整个<code>fmap</code>的类型签名会变为：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="p">((</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div>
<p>问题也就变为，如何构造出一个函数使得其类型为<code>(a -&gt; b, a) -&gt; b</code>，这样就很简单了</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">mf</span> <span class="o">&lt;*&gt;</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">mf</span> <span class="o">**</span> <span class="n">mx</span><span class="p">)</span>
</code></pre></div>
<p>这里另外介绍一个技巧（或者说是idiom）：<code>\(f, x) -&gt; f x</code>可以写成<code>uncurry id</code>。</p>

<p>很脏。首先来检查一下<code>uncurry</code>的类型：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">uncurry</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">c</span>
</code></pre></div>
<p>因为<code>(-&gt;)</code>是右结合的，所以上面的类型也可以写成</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">uncurry</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">c</span>
  <span class="kr">where</span> <span class="n">d</span> <span class="o">::</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
</code></pre></div>
<p>也就是说如果你给我一个返回另外一个一元函数的一元函数，并且给我两个参数，我能帮你计算出结果。如果要把<code>id :: a -&gt; a</code>提供给它，那么<code>id</code>的参数必须是一个一元函数，也就是说它必须变形为<code>id :: (b -&gt; c) -&gt; (b -&gt; c)</code>，那么就有了</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">uncurry</span> <span class="n">id</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">c</span>
</code></pre></div>
<p>这跟我们上面推理出的<code>(a -&gt; b, a) -&gt; b</code>的类型恰好一样。</p>

<p>用<code>pure</code>来实现<code>unit</code>很简单：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">unit</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="nb">()</span>
<span class="n">unit</span> <span class="o">=</span> <span class="n">pure</span> <span class="nb">()</span>
</code></pre></div>
<p>用Applicative方法来实现<code>(**)</code>，首先检查类型</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">**</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>我们可以观察出<code>(&lt;*&gt;)</code>与<code>(**)</code>的类型很相似，而且要使用<code>(&lt;*&gt;)</code>来获得<code>(**)</code>的结果。那么不妨将<code>(&lt;*&gt;)</code>的返回值类型特化为<code>f (a, b)</code>，这样<code>(&lt;*&gt;)</code>的整个类型就是：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>接下来就是如何构造这样一个函数<code>t -&gt; (a, b)</code>使得我们可以利用已知量<code>f a</code>与<code>f b</code>。很自然的想法是构造一个这样的二元函数<code>\a b -&gt; (a, b)</code>，这样我们就可以</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">**</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">fa</span> <span class="o">**</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">&lt;*&gt;</span> <span class="n">fa</span> <span class="o">&lt;*&gt;</span> <span class="n">fb</span>
</code></pre></div>
<p>或者</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fa</span> <span class="o">**</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">pure</span> <span class="p">(,)</span> <span class="o">&lt;*&gt;</span> <span class="n">fa</span> <span class="o">&lt;*&gt;</span> <span class="n">fb</span>
</code></pre></div>
<p>看到这，你就会觉得上面的推导其实是复杂化了。我们可以这样理解：将元组构造器<code>(,)</code>通过<code>pure</code>提升到Applicative中，然后将两个已经在Applicative里的已知量通过<code>(&lt;*&gt;)</code>应用到<code>pure (,)</code>上。</p>

<h2>Monad 单子</h2>

<h3>实现列表的单子实例</h3>

<p>要注意到这里的列表指的并不是<code>ZipList</code>。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
  <span class="n">f</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="n">fs</span><span class="p">)</span>
  <span class="c1">-- 首先通过(fmap ($) fs)取得[($) f]，然后将每一个(($) f)通过fmap应用于xs，最后</span>
  <span class="c1">-- concat一下来满足类型约束。</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span>
</code></pre></div>
<p>接下来检查一下单子所要满足的规律</p>

<p>左恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>
  <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">f</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="n">f</span><span class="p">]))</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">f</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">[(</span><span class="n">f</span> <span class="o">$</span><span class="p">)])</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="n">x</span><span class="p">]])</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">concat</span> <span class="p">[[</span><span class="n">f</span> <span class="n">x</span><span class="p">]])</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div>
<p>右恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">pure</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">pure</span> <span class="n">pure</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">pure</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="n">pure</span><span class="p">]))</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span> <span class="p">[(</span><span class="n">pure</span> <span class="o">$</span><span class="p">)]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">(</span><span class="n">pure</span> <span class="o">$</span><span class="p">)</span> <span class="n">xs</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">(</span><span class="n">pure</span> <span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[(</span><span class="n">pure</span> <span class="o">$</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="n">pure</span> <span class="o">$</span> <span class="n">x2</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">pure</span> <span class="o">$</span> <span class="n">xk</span><span class="p">),</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[(</span><span class="n">pure</span> <span class="n">x1</span><span class="p">),</span> <span class="p">(</span><span class="n">pure</span> <span class="n">x2</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">pure</span> <span class="n">xk</span><span class="p">),</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[[</span><span class="n">x1</span><span class="p">],</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="n">xk</span><span class="p">],</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[</span><span class="n">x1</span><span class="p">],</span> <span class="p">[</span><span class="n">x2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="p">[</span><span class="n">xk</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
  <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">xs</span>
</code></pre></div>
<p>结合律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">pure</span> <span class="n">g</span> <span class="o">&lt;*&gt;</span> <span class="n">f</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="n">f</span> <span class="n">y</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="p">(</span><span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">h</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">))</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="n">g</span><span class="p">])))</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">h</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">))</span> <span class="p">[(</span><span class="n">g</span> <span class="o">$</span><span class="p">)])</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">(</span><span class="n">g</span> <span class="o">$</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)])</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[</span><span class="n">g</span> <span class="n">fy1</span><span class="p">,</span> <span class="n">g</span> <span class="n">fy2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">g</span> <span class="n">fyk</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="p">[</span><span class="n">g</span> <span class="n">fy1</span><span class="p">,</span> <span class="n">g</span> <span class="n">fy2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">g</span> <span class="n">fyk</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">concat</span> <span class="p">[[</span><span class="n">gfy11</span><span class="p">,</span> <span class="n">gfy12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfy1k</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                          <span class="p">[</span><span class="n">gfy21</span><span class="p">,</span> <span class="n">gfy22</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfy2k</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                          <span class="o">...</span><span class="p">,</span>
                          <span class="p">[</span><span class="n">gfyk1</span><span class="p">,</span> <span class="n">gfyk2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfykk</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                          <span class="o">...</span><span class="p">,])</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">gfy11</span><span class="p">,</span> <span class="n">gfy12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfy21</span><span class="p">,</span> <span class="n">gfy22</span><span class="p">,</span> <span class="o">...</span> <span class="n">gfyk1</span><span class="p">,</span> <span class="n">gfyk2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>

<span class="kr">let</span> <span class="n">gfypq</span> <span class="o">=</span> <span class="p">[</span><span class="n">gfy11</span><span class="p">,</span> <span class="n">gfy12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfy21</span><span class="p">,</span> <span class="n">gfy22</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfyk1</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>

    <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">gfypq</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">gfypq</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">h</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">gfypq</span><span class="p">])</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">h</span> <span class="n">xs</span><span class="p">)</span> <span class="p">[((</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">gfypq</span><span class="p">)</span> <span class="o">$</span><span class="p">)]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">((</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">gfypq</span><span class="p">)</span> <span class="o">$</span><span class="p">)</span> <span class="n">xs</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">((</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">gfypq</span><span class="p">)</span> <span class="o">$</span><span class="p">)</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[</span><span class="n">gfx1pq</span><span class="p">,</span> <span class="n">gfx2pq</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfxkpq</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">[[</span><span class="n">gfx111</span><span class="p">,</span> <span class="n">gfx112</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfx121</span><span class="p">,</span> <span class="n">gfx122</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="p">[</span><span class="n">gfx211</span><span class="p">,</span> <span class="n">gfx212</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfx221</span><span class="p">,</span> <span class="n">gfx222</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="o">...</span><span class="p">,</span>
            <span class="p">[</span><span class="n">gfxk11</span><span class="p">,</span> <span class="n">gfxk12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfxk21</span><span class="p">,</span> <span class="n">gfxk22</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="o">...</span><span class="p">]</span>
  <span class="o">=</span> <span class="p">[</span><span class="n">gfx111</span><span class="p">,</span> <span class="n">gfx112</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfx121</span><span class="p">,</span> <span class="n">gfx122</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfxk11</span><span class="p">,</span> <span class="n">gfxk12</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="p">(</span><span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span> <span class="p">[(</span><span class="n">f</span> <span class="o">$</span><span class="p">)])</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">$</span><span class="p">)</span> <span class="n">xs</span><span class="p">])</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[</span><span class="n">f</span> <span class="n">x1</span><span class="p">,</span> <span class="n">f</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">f</span> <span class="n">xk</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">concat</span> <span class="p">[</span><span class="n">f</span> <span class="n">x1</span><span class="p">,</span> <span class="n">f</span> <span class="n">x2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">f</span> <span class="n">xk</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">concat</span> <span class="p">[[</span><span class="n">fx11</span><span class="p">,</span> <span class="n">fx12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx1k</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
             <span class="p">[</span><span class="n">fx21</span><span class="p">,</span> <span class="n">fx22</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx2k</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
             <span class="o">...</span><span class="p">,</span>
             <span class="p">[</span><span class="n">fxk1</span><span class="p">,</span> <span class="n">fxk2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fxkk</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">[</span><span class="n">fx11</span><span class="p">,</span> <span class="n">fx12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx1k</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx21</span><span class="p">,</span> <span class="n">fx22</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx2k</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>

<span class="kr">let</span> <span class="n">fxpq</span> <span class="o">=</span> <span class="p">[</span><span class="n">fx11</span><span class="p">,</span> <span class="n">fx12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx1k</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx21</span><span class="p">,</span> <span class="n">fx22</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">fx2k</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>

    <span class="p">(</span><span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="n">fxpq</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="n">fxpq</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">h</span> <span class="o">-&gt;</span> <span class="n">fmap</span> <span class="n">h</span> <span class="n">fxpq</span><span class="p">)</span> <span class="p">[(</span><span class="n">g</span> <span class="o">$</span><span class="p">)]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[</span><span class="n">fmap</span> <span class="p">(</span><span class="n">g</span> <span class="o">$</span><span class="p">)</span> <span class="n">fxpq</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">concat</span> <span class="o">$</span> <span class="p">[[</span><span class="n">g</span> <span class="n">fx11</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx1k</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx21</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">[</span><span class="n">g</span> <span class="n">fx11</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx12</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx1k</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx21</span><span class="p">,</span> <span class="n">g</span> <span class="n">fx22</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">concat</span> <span class="p">[[</span><span class="n">gfx111</span><span class="p">,</span> <span class="n">gfx112</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="p">[</span><span class="n">gfx121</span><span class="p">,</span> <span class="n">gfx122</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="o">...</span><span class="p">,</span>
            <span class="p">[</span><span class="n">gfxpq1</span><span class="p">,</span> <span class="n">gfxpq2</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="o">...</span><span class="p">]</span>
  <span class="o">=</span> <span class="p">[</span><span class="n">gfx111</span><span class="p">,</span> <span class="n">gfx112</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfx121</span><span class="p">,</span> <span class="n">gfx122</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">gfxpq1</span><span class="p">,</span> <span class="n">gfxpq2</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
  <span class="o">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</code></pre></div>
<p>如果用更简单的<code>(&gt;&gt;=)</code>实现（比如<code>base</code>包里给出的使用列表解析的实现），结合律的证明可能不会这么复杂。</p>

<h3>实现<code>((-&gt;) e)</code>的单子实例</h3>

<p><code>((-&gt;) e)</code>的函子实例前面已经实现过，这里不再重复。</p>

<p>首先来实现<code>((-&gt;) e)</code>的Applicative实例，<code>pure</code>很trivial：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">x</span>
<span class="c1">-- or</span>
<span class="n">pure</span> <span class="o">=</span> <span class="n">const</span>
</code></pre></div>
<p>接下来看<code>(&lt;*&gt;)</code>特化为<code>((-&gt;) e)</code>的类型：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- i.e.</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- 由于(-&gt;)是右结合的</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>沿着这个类型，它的具体实现就很清楚了，<code>f :: e -&gt; a -&gt; b</code>，<code>g :: e -&gt; a</code>，我们要得到一个<code>e -&gt; b</code>类型的返回值，首先要做的是创建一个接受一个<code>e</code>的函数，即<code>\e -&gt; ???</code>。然后使用<code>g e</code>获得一个<code>a</code>类型的值。根据之前的推理，将这个<code>a</code>类型的值与<code>e</code>一起作用于<code>f</code>可以得到一个<code>b</code>，即</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">e</span> <span class="p">(</span><span class="n">g</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div>
<p>如果你看Haskell的源码，你会发现其实它是这么实现的：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- 由于(-&gt;)右结合</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div>
<p>这也就告诉我们，上面的式子可以这么写：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f</span> <span class="n">e</span> <span class="p">(</span><span class="n">g</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div>
<p>下面实现<code>((-&gt;) e)</code>的单子实例：它的<code>(&gt;&gt;=)</code>类型应该是</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- =&gt;</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- =&gt;</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div>
<p>那么</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">e</span> <span class="o">=</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span>
  <span class="c1">-- or f &gt;&gt;= g = \e -&gt; g (f e) e</span>
</code></pre></div>
<p>接下来检查这个实现的性质：</p>

<p>左恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">return</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="p">((</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">f</span> <span class="n">e</span>
  <span class="o">=</span> <span class="n">g</span> <span class="n">f</span>
</code></pre></div>
<p>右恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">pure</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">e</span><span class="p">)</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">e</span>
  <span class="o">=</span> <span class="n">f</span>
</code></pre></div>
<p>结合律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="n">g</span> <span class="n">t</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span><span class="p">))</span>
  <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="n">g</span> <span class="n">t</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span>  <span class="c1">-- uncurry</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e'</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">t</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="n">g</span> <span class="n">t</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">e'</span><span class="p">)</span> <span class="n">e'</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e'</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">e'</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="n">e'</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e'</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="p">(</span><span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">e'</span><span class="p">)</span> <span class="n">e'</span><span class="p">)</span> <span class="n">e'</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">e'</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="p">((</span><span class="nf">\</span><span class="n">k</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">k</span><span class="p">)</span> <span class="n">k</span><span class="p">)</span> <span class="n">e'</span><span class="p">)</span> <span class="n">e'</span>
  <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">k</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">k</span><span class="p">)</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span>  <span class="c1">-- \e' -&gt; h (K e') e' = K &gt;&gt;= h</span>
  <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span>          <span class="c1">-- 同理</span>
</code></pre></div>
<h3>实现以下数据类型的函子与单子</h3>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="c1">-- Functor f =&gt;</span>
<span class="kr">data</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Var</span> <span class="n">a</span>
              <span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div>
<p>既然我们在实现关于<code>Free f</code>的函子实例，我们就可以假设它是一个函子。那么对于<code>Free f a</code>，它的<code>fmap</code>的类型是</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div>
<p>对于<code>Var a</code>，<code>fmap</code>很简单</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">g</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">Var</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Var</span> <span class="o">$</span> <span class="n">g</span> <span class="n">x</span>
</code></pre></div>
<p>对于<code>Node t</code>，我们可以观察出来，<code>a</code>实际上是裹在两层函子里的，即首先它裹在<code>Free f a</code>这一个函子里，同时这个函子又裹在<code>f</code>这个函子里，那么根据之前的结论，去访问裹在两层函子里的值，我们用<code>fmap . fmap</code>，即</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">g</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="kt">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="p">(</span><span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span><span class="p">)</span> <span class="n">g</span> <span class="n">t</span>
</code></pre></div>
<p>接下来实现<code>Free f a</code>的Applicative实例：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">pure</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span>
<span class="c1">-- =&gt;</span>
<span class="n">pure</span> <span class="o">=</span> <span class="kt">Var</span>

<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span>
<span class="c1">-- =&gt;</span>
<span class="kt">Var</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">free</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">free</span>
<span class="kt">Node</span> <span class="n">t</span> <span class="o">&lt;*&gt;</span> <span class="n">free</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div>
<p>接下来考虑<code>Node t</code>的情况，这里的<code>t</code>实际上是一个<code>f (Free f (a -&gt; b))</code>（观察它的<code>data</code>定义的第二句<code>Node (f (Free f a))</code>），即</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">t</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">t'</span>
  <span class="kr">where</span> <span class="n">t'</span> <span class="o">::</span> <span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>而<code>free</code>则是一个<code>Free f a</code>，我们要解决的问题就是将<code>a -&gt; b</code>应用到<code>a</code>上。我们最自然的想法，是递归地利用<code>(&lt;*&gt;)</code>使得<code>t</code>中的<code>t&#39; :: Free f (a -&gt; b)</code>能够与<code>Free f a</code>作用，即我们想要得到<code>t&#39; &lt;*&gt; free</code>。</p>

<p>然而<code>t&#39;</code>我们是不能直接得到的，它还裹在一个<code>f</code>中。回想起<code>fmap</code>的另一种理解方式：它将一个函数提升至对应的函子上下文中，即：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="n">fmap</span> <span class="n">f</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div>
<p>那么我们可以利用函子<code>f</code>的<code>fmap</code>将<code>(&lt;*&gt; free)</code>提升至函子<code>f</code>中，得到一个提升过的函数，再将<code>t</code>应用于这个函数上。更具体地，我们可以特化这其中的<code>a</code>为<code>Free f c</code>，<code>b</code>为<code>Free f d</code>，得到下面的类型</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">d</span><span class="p">)</span>
<span class="c1">-- 将c换为a -&gt; b，d换为b</span>
<span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>

<span class="c1">-- 而</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="n">free</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span> 

<span class="c1">-- 则</span>
<span class="n">fmap</span> <span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="n">free</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>这样，我们就可以把<code>t</code>应用于上面得到的式子：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kt">Node</span> <span class="n">t</span> <span class="o">&lt;*&gt;</span> <span class="n">free</span> <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">&lt;*&gt;</span> <span class="n">free</span><span class="p">)</span> <span class="n">t</span>
</code></pre></div>
<p>接下来实现<code>Free f a</code>的单子实例：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Var</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span>
  <span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="o">...</span>
</code></pre></div>
<p>关于<code>Node t</code>，同样的</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">t</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">t'</span>
  <span class="kr">where</span> <span class="n">t'</span> <span class="o">::</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span>

<span class="n">f</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div>
<p>而<code>(&gt;&gt;=)</code>的类型为：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div>
<p>则我们自然地想到，可以递归地利用<code>(&gt;&gt;=)</code>，来让<code>t&#39; &gt;&gt;= f</code>，然而<code>t&#39;</code>仍然裹在一层函子<code>f</code>中，那么简单地利用函子<code>f</code>的<code>fmap</code>将<code>(&gt;&gt;= f)</code>提升至函子<code>f</code>中即可，即</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="n">t</span>
</code></pre></div>
<p>至此，<code>Free f a</code>的单子实例的推导结束。</p>

<p>可以看到，在上面的推导中，我们打了大量的类型运算的草稿，并且通过这些类型，我们能够对具体的实现有一种直观上的感受。通过类型运算来指引具体的实现在Haskell中是很重要的一个技巧。</p>

<p>接下来检查该实现是否符合各个单子律：</p>

<p>左恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">return</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">a</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">a</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">a</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="n">k</span> <span class="p">(</span><span class="kt">Var</span> <span class="n">a</span><span class="p">)</span>

    <span class="n">return</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">t</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="kt">Var</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">t</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="n">k</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div>
<p>右恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="kt">Var</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="kt">Var</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="kt">Var</span>
  <span class="o">=</span> <span class="kt">Var</span> <span class="n">a</span>

    <span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="kt">Var</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="kt">Var</span><span class="p">)</span> <span class="n">t</span>

<span class="c1">-- 若 t = f (Var a)，则</span>
    <span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="kt">Var</span><span class="p">)</span> <span class="n">t</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Var</span> <span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="kt">Var</span><span class="p">)</span> <span class="n">t</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">t</span>  <span class="c1">-- 请通过类型运算让自己相信这一步是正确的</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="n">t</span>

<span class="c1">-- 若 t = f (Node u)，则</span>
    <span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Node</span> <span class="n">u</span> <span class="o">&gt;&gt;=</span> <span class="kt">Var</span><span class="p">)</span> <span class="n">t</span>

<span class="c1">-- 递归至第一步，如果t有穷（其递归结构终止于Var a）,则</span>
    <span class="kt">Node</span> <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="o">$</span> <span class="n">t</span>  <span class="c1">-- 请通过类型运算让自己相信这一步是正确的</span>
  <span class="o">=</span> <span class="kt">Node</span> <span class="n">t</span>
</code></pre></div>
<p>结合律：太复杂，在简单的方法里我证明不出来。</p>

<h3>利用<code>fmap</code>和<code>join</code>实现<code>(&gt;&gt;=)</code></h3>

<p>首先检查他们的类型：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">y</span>
<span class="n">join</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div>
<p>然后检查已知量：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">b</span>
  <span class="kr">where</span> <span class="n">m</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span>
        <span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div>
<p>看到<code>f :: a -&gt; m b</code>和<code>fmap</code>的第一个参数，不妨将<code>y</code>特化为<code>m b</code>，那么就有</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div>
<p>看到这样的返回值类型就能很自然地将<code>join</code>联想起来了：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">join</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div>
<h3>利用<code>(&gt;&gt;=)</code>和<code>return</code>实现<code>join</code>和<code>fmap</code></h3>

<p>类型就不再赘述。已知量如下：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">join</span> <span class="n">x</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span>
  <span class="kr">where</span> <span class="n">x</span> <span class="o">::</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span>

<span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="o">::</span> <span class="n">m</span> <span class="n">b</span>
  <span class="kr">where</span> <span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
        <span class="n">m</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></div>
<p><code>join</code>很简单：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">join</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x'</span> <span class="o">-&gt;</span> <span class="n">x'</span>
<span class="c1">-- i.e.</span>
<span class="n">join</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">id</span>
</code></pre></div>
<p>观察到<code>f</code>与<code>(&gt;&gt;=)</code>中的第二个参数的类型相似，其可以用<code>return . f</code>来表示，那么<code>fmap</code>也很简单：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>
<h3>证明关于<code>(&gt;=&gt;)</code>的规则与一般的单子规则是等价的</h3>

<p>其中<code>(&gt;=&gt;)</code>的定义如下：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">g</span> <span class="o">&gt;=&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span>
</code></pre></div>
<p>左恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">return</span> <span class="o">&gt;=&gt;</span> <span class="n">g</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">x</span>  <span class="c1">-- 通常的左恒等律</span>
  <span class="o">=</span> <span class="n">g</span>
</code></pre></div>
<p>即证明了，当且仅当通常的左恒等律成立时，关于<code>(&gt;=&gt;)</code>的左恒等律成立。也就说明这条左恒等律与通常的左恒等律等价。</p>

<p>右恒等律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="n">g</span> <span class="o">&gt;=&gt;</span> <span class="n">return</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">x</span>  <span class="c1">-- 通常的右恒等律</span>
  <span class="o">=</span> <span class="n">g</span>
</code></pre></div>
<p>结合律：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell">    <span class="p">(</span><span class="n">g</span> <span class="o">&gt;=&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="o">&gt;=&gt;</span> <span class="n">k</span>
  <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span><span class="p">)</span> <span class="o">&gt;=&gt;</span> <span class="n">k</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span><span class="p">)</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="n">h</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span><span class="p">)</span>  <span class="c1">-- (&gt;&gt;=)的结合律</span>
  <span class="o">=</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;=&gt;</span> <span class="n">k</span><span class="p">)</span>  <span class="c1">-- (&gt;=&gt;)的定义</span>
  <span class="o">=</span> <span class="n">g</span> <span class="o">&gt;=&gt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;=&gt;</span> <span class="n">k</span><span class="p">)</span>  <span class="c1">-- (&gt;=&gt;)的定义</span>
</code></pre></div>
<h3>给定<code>distrib :: N (M a) -&gt; M (N a)</code>，实现以下函数</h3>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">join</span> <span class="o">::</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">N</span> <span class="p">(</span><span class="kt">M</span> <span class="p">(</span><span class="kt">N</span> <span class="n">a</span><span class="p">)))</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">N</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div>
<p>如果你熟悉do记法，这个就比较简单了：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">join</span> <span class="n">mnmna</span> <span class="o">=</span> <span class="kr">do</span> <span class="n">nmna</span> <span class="o">&lt;-</span> <span class="n">mnmna</span>
                <span class="n">nna</span> <span class="o">&lt;-</span> <span class="n">distrib</span> <span class="n">nmna</span>  <span class="c1">-- 得到 M (N (N a))</span>
                <span class="n">na</span> <span class="o">&lt;-</span> <span class="n">join</span> <span class="n">nna</span>
                <span class="n">return</span> <span class="n">na</span>
</code></pre></div>
<h2>Foldable 折子(?)</h2>

<h3><code>foldMap . foldMap</code>是什么类型？有什么用？</h3>

<p>在GHCi里使用<code>:t &lt;expr&gt;</code>可以查看<code>&lt;expr&gt;</code>的类型。</p>

<p><code>foldMap . foldMap</code>可以折叠两层嵌套的不同折子到一个幺半群（Monoid）上。</p>

<h3>实现<code>toList :: Foldable f =&gt; f a -&gt; [a]</code></h3>

<p>既然我们已经知道<code>[]</code>是一个幺半群，那么我们可以使用<code>foldMap</code>将<code>f</code>折叠为一个幺半群。已知<code>foldMap</code>的类型是：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">foldMap</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span>

<span class="n">toList</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">toList</span> <span class="o">=</span> <span class="n">foldMap</span> <span class="n">pure</span>
</code></pre></div>
<h3>实现<code>concat</code>，<code>concatMap</code>，<code>and</code>，<code>or</code>，<code>any</code>，<code>all</code>，<code>sum</code>，<code>product</code>等函数，并弄明白如何联合使用折子与幺半群来优雅地实现它们</h3>

<p>我们总是想优先使用<code>foldMap</code>，因为它需要的参数少（不需要初始值）。当发现<code>foldMap</code>对于给定的问题不合适之后才考虑<code>foldr</code>或者<code>foldl</code>以及他们的变体。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">concat</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">concat</span> <span class="o">=</span> <span class="n">foldMap</span> <span class="n">id</span>  <span class="c1">-- 因为f [a]里的[a]已经是一个Monoid了，所以直接id就行了</span>

<span class="n">concatMap</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">concatMap</span> <span class="o">=</span> <span class="n">foldMap</span>  <span class="c1">-- concatMap实际上是foldMap里Monoid m特化为[]的一个特殊情况</span>

<span class="n">and</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">and</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="kt">True</span>

<span class="n">or</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="kt">Bool</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">or</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span> <span class="kt">False</span>
</code></pre></div>
<p><code>any</code>, <code>all</code>, <code>sum</code>, <code>product</code>这几个函数的特点是，它们操作的对象都可以在多种运算符和空值下构成幺半群，比如整数可以在<code>(+)</code>与0下构成一个幺半群，也可以在<code>(*)</code>与1下构成一个幺半群。所以如果我们使用<code>newtype</code>来构建新的类型，并实现它们的幺半群实例。这样就可以使用<code>foldMap</code>来优雅地实现上面说的函数了。（当然如果直接用<code>foldr</code>或者<code>foldl</code>也不是不可以。但是<code>newtype</code>出来的类型不光在这里有用，在别的地方也有可能用得到，所以这里我们用使用<code>newtype</code>的写法。）</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">newtype</span> <span class="kt">Any</span> <span class="o">=</span> <span class="kt">Any</span> <span class="p">{</span> <span class="n">getAny</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Any</span> <span class="kr">where</span>
  <span class="n">mempty</span> <span class="o">=</span> <span class="kt">Any</span> <span class="kt">False</span>
  <span class="kt">Any</span> <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Any</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Any</span> <span class="o">$</span> <span class="n">a</span> <span class="o">||</span> <span class="n">b</span>

<span class="n">any</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">any</span> <span class="n">f</span> <span class="o">=</span> <span class="n">getAny</span> <span class="o">.</span> <span class="n">foldMap</span> <span class="p">(</span><span class="kt">Any</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>


<span class="kr">newtype</span> <span class="kt">All</span> <span class="o">=</span> <span class="kt">All</span> <span class="p">{</span> <span class="n">getAll</span> <span class="o">::</span> <span class="kt">Bool</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">All</span> <span class="kr">where</span>
  <span class="n">mempty</span> <span class="o">=</span> <span class="kt">All</span> <span class="kt">True</span>
  <span class="kt">All</span> <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">All</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">All</span> <span class="o">$</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">b</span>

<span class="n">all</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">all</span> <span class="n">f</span> <span class="o">=</span> <span class="n">getAll</span> <span class="o">.</span> <span class="n">foldMap</span> <span class="p">(</span><span class="kt">All</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">Sum</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Sum</span> <span class="p">{</span> <span class="n">getSum</span> <span class="o">::</span> <span class="n">a</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Sum</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">mempty</span> <span class="o">=</span> <span class="kt">Sum</span> <span class="mi">0</span>
  <span class="kt">Sum</span> <span class="n">a</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Sum</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Sum</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

<span class="n">sum</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Foldable</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">sum</span> <span class="o">=</span> <span class="n">getSum</span> <span class="o">.</span> <span class="n">foldMap</span> <span class="kt">Sum</span>

<span class="c1">-- product不再赘述</span>
</code></pre></div>
<p>接下来看看<code>maximumBy</code>的类型：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">maximumBy</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Ordering</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div>
<p>我们已经知道<code>Ordering</code>是一个幺半群了，看到幺半群就会自然地想到使用<code>foldMap</code>，然而<code>foldMap</code>中计算出来的幺半群就是它的结果，但是<code>maximumBy</code>的结果却不是一个幺半群。所以这里使用<code>foldMap</code>可能不太好。我们使用<code>foldr1</code>来实现它，因为<code>foldr1</code>是<code>foldr</code>的特化版本，它不需要使用者提供初始值。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">maximumBy</span> <span class="n">f</span> <span class="o">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">x</span> <span class="n">acc</span> <span class="kr">of</span>
                         <span class="kt">LT</span> <span class="o">-&gt;</span> <span class="n">acc</span>
                         <span class="kt">EQ</span> <span class="o">-&gt;</span> <span class="n">acc</span>
                         <span class="kt">GT</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div>
<p><code>elem x xs</code>返回一个<code>Bool</code>。当<code>xs</code>中至少有一个<code>x</code>时，它返回<code>True</code>，否则返回<code>False</code>。这让我们联想到构造一个这样的函数<code>\a -&gt; a == x</code>并使用<code>or</code>。然而<code>or</code>需要的是<code>f Bool</code>，这里仅仅保证了<code>f</code>是一个折子，并不保证它是一个函子，所以我们无法将<code>f a</code>映射至<code>f Bool</code>。（你当然可以<code>or $ map (== x) (toList xs)</code>，但是我们有更好的方法。）</p>

<p>换个思路：当<code>xs</code>中至少有一个<code>x</code>时，这句话也就是<code>xs</code>中的任意一个元素等于<code>x</code>时，也就是说我们可以使用<code>any</code>！</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">elem</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Foldable</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">elem</span> <span class="n">x</span> <span class="o">=</span> <span class="n">any</span> <span class="p">(</span><span class="o">==</span> <span class="n">x</span><span class="p">)</span>

<span class="c1">-- 源码中的实现更简单 elem = any . (==)</span>
</code></pre></div>
<p><code>find</code>的返回值类型是<code>Maybe a</code>，当且仅当<code>a</code>是一个幺半群的时候<code>Maybe a</code>是一个幺半群。然而<code>find</code>的类型约束并不保证<code>a</code>是一个幺半群。所以这里我们尝试使用<code>foldr</code>，并且从<code>Nothing</code>开始折叠。</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">find</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">find</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">pred</span> <span class="n">x</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Nothing</span>
</code></pre></div>
<p>这个实现会遍历所有可能的元素，返回最后一个遍历到的符合条件的元素。</p>

<p>源码中利用了一个叫<code>First a :: { getFirst :: Maybe a }</code>的幺半群结构。这个结构说在<code>mappend</code>的时候，如果左边的<code>First</code>的值是Nothing，那么它的结果是<code>mappend</code>右边的值，否则这个<code>mappend</code>结果是左边的值。也就是说，如果利用这个幺半群与<code>foldMap</code>，我们可以返回第一个符合条件的元素（虽然不一定会在那个时候就返回）：</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">find</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">getFirst</span> <span class="o">.</span> <span class="n">foldMap</span> <span class="o">$</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="kt">First</span> <span class="p">(</span><span class="kr">if</span> <span class="n">pred</span> <span class="n">x</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">x</span> <span class="kr">else</span> <span class="kt">Nothing</span><span class="p">)</span>
</code></pre></div>
<h2>Traversable 遍子(?)</h2>

<h3>至少有两种自然的方式把一个由<code>[]</code>组成的树转换为一个由树组成的<code>[]</code>，它们是哪两种？</h3>

<p>参照<code>[]</code>的两种意义：一种代表不确定的计算结果，一种代表并列的、有序的数据（即<code>ZipList</code>）。</p>

<p>如果树里的每一个节点上的<code>[]</code>代表的时候不确定的结算结果，那么我们可以将这个树展开，每个节点上的<code>[]</code>里的一个元素代表在这个节点的可能的元素，我们会得到<strong>很多</strong>树（类似集合的笛卡尔乘积）。</p>

<p>另一种则是，把每个节点的<code>[]</code>的第一个元素拿出来组成一个树，每个节点的第二个元素拿出来组成一个树，以此类推。我们可以得到<code>minimum . toList tree</code>个树。</p>

<h3>给出一种将由树组成的<code>[]</code>转换成由<code>[]</code>组成的树的方法</h3>

<p>可以将列表里的树按照坐标zip起来。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>呓，黑历史</title>
      <link href="http://qwert42.github.io/2016/01/21/a/"/>
      <pubDate>2016-01-21T00:00:00-05:00</pubDate>
      <author>qwert42</author>
      <guid>http://qwert42.github.io/2016/01/21/a</guid>
      <content:encoded><![CDATA[<p>换了个域名重新上线了。</p>

<p>Oh my painful memories!</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>pickle模块简介与一个简单的clojure实现</title>
      <link href="http://qwert42.github.io/2013/06/26/brief-analysis-on-pickle-and-an-implementation-in-clojure/"/>
      <pubDate>2013-06-26T00:00:00-04:00</pubDate>
      <author>qwert42</author>
      <guid>http://qwert42.github.io/2013/06/26/brief-analysis-on-pickle-and-an-implementation-in-clojure</guid>
      <content:encoded><![CDATA[<p>有段时间突然对二进制的数据产生了强烈的兴趣（具体原因可能是因为解析坦克世界的<code>dossier.dat</code>可以获得平时看不到的数据），寒假在家也闲不住，就跑去研究了一下pickle这个模块（坦克世界的那些数据实际上也就是pickle之后的东西）。然后用clojure做了一个<a href="https://github.com/mad4alcohol/naive-unpickler-clj">简易的unpickle库</a>，未来可能在有时间的时候会添加pickle的功能。</p>

<h2>准备工作</h2>

<p>如何去了解一个不了解的东西？Google。Google不到怎么破？源码。</p>

<p>翻了一下python的<code>Lib</code>文件夹，发现了两个有关的东西：<code>pickle.py</code>，<code>pickletools.py</code>。打开<code>pickletools.py</code>看一下，<code>&quot;Executable documentation&quot; for the pickle module</code>，看来是找对地方了。</p>

<h2>pickle的简介</h2>

<p>文档说的总会比我说的清楚，这里就摘抄几段文档了。</p>

<p>一个&quot;pickle&quot;是一个给pickle虚拟机（PM）使用的程序。它是一系列的操作码（opcode），被PM解释后，用来创建任意复杂的Python对象。总体来说PM非常简单：操作码每个被执行一次，从第一个到最后一个，直到碰到了<code>STOP</code>操作码。</p>

<p>PM有两个数据域：栈（stack）和备忘（memo）。</p>

<p>许多操作码把Python对象压到栈里，比如<code>INT</code>把一个Python整数对象压到栈里，这个整数对象的值从一个在pickle字节流中紧跟在<code>INT</code>操作码后面的十进制字符串字面量中取得。另外有一些操作码把Python对象弹出栈中。unpickling的结果就是当执行到<code>STOP</code>操作码时，留在栈顶的那个东西了。</p>

<p>备忘仅仅只是一个存放对象的数组，或者也能被实现成一个从小整数映射到对象的字典。备忘是PM的“长期记忆”，那些为备忘提供索引的小整数类似于变量名。有些操作码把对象从栈顶弹出后放入备忘的一个指定索引里，另外一些把给定索引处的备忘对象再压回栈里。</p>

<p>以上基本上就是pickle的工作原理了。</p>

<p>具体的pickle操作码的定义被称为pickle协议，由于历史原因pickle协议存在多个版本，但是令人感到安心的是，pickle操作码的意义永远不变，即高版本兼容低版本，令人感到不安的是，对于实现者工作量就会大些了。</p>

<p>最原始的pickle现在被称为“协议0”，并且在Python 2.3前被称为“文字模式（text mode）”。整个pickle字节流由可打印的7位ASCII字符加上换行符组成。这也是它被称为文字模式的原因。协议0小且优雅，但是有时极其低效。</p>

<p>第二个主要的协议版本现在被称为“协议1”，并且在Python 2.3前被称为“二进制模式（binary mode）”。增加了许多参数可以包含任意长度字节的操作码。通常二进制模式的pickle比文字模式的占用的空间要小，有时也会更快。协议1也添加了几个立即操作多个栈上元素的操作码（如<code>APPENDS</code>和<code>SETITEMS</code>）和“快捷”操作码（如<code>EMPTY_DICT</code>和<code>EMPTY_TUPLE</code>）。</p>

<p>第三个主要的协议版本在Python 2.3中被引入，被称作“协议2”。具体内容这里就略去了。因为这篇文章只会用clojure实现协议1（当然也包括了协议0），协议2等我熟悉了clojure的面向对象编程再说吧。</p>

<h2>在开始实现之前</h2>

<p>先阅读一下<code>pickletools.py</code>的其他部分，翻了一下，在883行发现了一个叫<code>opcodes</code>的list，可以说是pickle协议的可执行版本，讲解了操作码的名称，码值，参数，执行前后栈的变化情况，提供该操作码的协议版本和该操作码的文档。</p>

<p>比如</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="n">I</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'LONG'</span><span class="p">,</span>
  <span class="n">code</span><span class="o">=</span><span class="s">'L'</span><span class="p">,</span>
  <span class="n">arg</span><span class="o">=</span><span class="n">decimalnl_long</span><span class="p">,</span>
  <span class="n">stack_before</span><span class="o">=</span><span class="p">[],</span>
  <span class="n">stack_after</span><span class="o">=</span><span class="p">[</span><span class="n">pylong</span><span class="p">],</span>
  <span class="n">proto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  <span class="n">doc</span><span class="o">=</span><span class="s">"""..."""</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>告诉我们<code>LONG</code>这个操作码，实际的码值（在字节流中的值）是&#39;L&#39;，即76，参数是<code>decimalnl_long</code>，在执行这个操作码后，栈上会多一个pylong对象，协议0提供这个操作码。</p>

<p>再看<code>decimalnl_long</code>是什么玩意，</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="n">decimalnl_long</span> <span class="o">=</span> <span class="n">ArgumentDescriptor</span><span class="p">(</span>
                     <span class="n">name</span><span class="o">=</span><span class="s">'decimalnl_long'</span><span class="p">,</span>
                     <span class="n">n</span><span class="o">=</span><span class="n">UP_TO_NEWLINE</span><span class="p">,</span>
                     <span class="n">reader</span><span class="o">=</span><span class="n">read_decimalnl_long</span><span class="p">,</span>
                     <span class="n">doc</span><span class="o">=</span><span class="s">"""A newline-terminated decimal integer literal.
                            ..."""</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>看doc说，<code>decimalnl_long</code>是一个以换行符结尾的十进制整数字面量。而且看它的<code>reader</code>项目可以看到这个参数的读取的具体实现，也就是<code>read_decimalnl_long</code>，如下</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">read_decimalnl_long</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">read_stringnl</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stripquotes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">"L"</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"trailing 'L' required in </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">long</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>这个函数实际上是很简单的，用<code>read_stringnl</code>读取一个以换行结尾的字符串，并且判断它尾巴上有没有一个<code>L</code>，如果有<code>L</code>就用built-in函数<code>long</code>把这个字符串转换成一个<code>long</code>对象。</p>

<p>如果总结一下，对字节流的操作可以综合成以下几个操作：</p>

<ul>
<li>读下一个字节</li>
<li>读下一行</li>
<li>读下四个字节</li>
<li>读下n个字节</li>
</ul>

<p>这也是会在clojure里实现的几个基本操作。</p>

<h2>开始实现</h2>

<p>如果仿照<code>pickletools.py</code>里的写法，在clojure里我们可以自己定义一个<code>defxxx</code>，比如<code>defopcode</code>，当然这个<code>defopcode</code>得用宏来实现。</p>

<p><code>defopcode</code>的基本操作就是修改维护的一个<code>map</code>，码值做键，具体的操作函数做值，这个操作函数接受三个参数，即字节流对象、栈对象和备忘对象，其中栈对象用<code>vector</code>实现，备忘对象用<code>map</code>实现，在函数内部对按照协议操作后，返回新的栈和备忘，作为下次执行所使用的栈和备忘。</p>

<p>在unpickle的时候，每次读入一个字节，然后通过这个<code>map</code>获得对应的操作函数，把需要的参数传递进去，并且接收好返回值，在loop的时候注意<code>STOP</code>操作码的判断，如果操作码是<code>STOP</code>，则立即停止recur，并返回栈顶元素。</p>

<p>在这个实现中有一个遗憾就是不能很好的实现<code>defopcode</code>这个宏，以至于每个操作码的定义后面都需要显式地写出返回值（即stack和memo）。</p>

<p>这里举一个例子</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">defopcode</span><span class="w"> </span><span class="n">BINUNICODE</span><span class="w"> </span><span class="sc">\X</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">len</span><span class="w"> </span><span class="p">(</span><span class="nf">from-byte-vector-lendian</span><span class="w"> </span><span class="p">(</span><span class="nf">next-4-byte</span><span class="p">))</span><span class="w">
        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="nf">next-n-byte</span><span class="w"> </span><span class="n">len</span><span class="p">)]</span><span class="w">
    </span><span class="p">[(</span><span class="nb">conj</span><span class="w"> </span><span class="n">stack</span><span class="w">
           </span><span class="p">(</span><span class="nf">String.</span><span class="w"> </span><span class="p">(</span><span class="nf">to-java-byte-array</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w">
                    </span><span class="s">"utf-8"</span><span class="p">))</span><span class="w">
     </span><span class="n">memo</span><span class="p">]))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>首先将字节流当前位置的后面4个字节读出来并且按小端（little endian）转换成一个<code>int</code>，使用的是自己写的函数<code>from-byte-vector-lendian</code>（python可以直接使用<code>struct.unpack</code>），绑定给<code>len</code>，随后又读取<code>len</code>个字节绑定给<code>data</code>，最后将<code>data</code>按<code>utf-8</code>解码为unicode的<code>String</code>后，压栈并返回。</p>

<p>这里不得不提的是java的<code>byte</code>类型很奇怪，竟然是带符号的，所以如果某个字节大于128（<code>0b10000000</code>）需要转换成<code>byte</code>，需要减掉256，把它变成负数，比如129（<code>0b10000001</code>）直接赋给<code>byte</code>是不行的，但是如果把它减掉256，变成-127，在补码下它的二进制表示仍然是<code>0b10000001</code>，这样就既没有破坏数据又可以被java接受了。</p>

<h2>后记</h2>

<p>感觉上用clojure实现协议1（包括部分协议2）的PM，要说的就是这么多（篇幅上来说比想象中的要短不少啊）。这回使用的编辑器依然是<font color=red>THE MIGHTY EMACS</font>，插件是很好用的nrepl，也算是体验了一下Lisp的开发方式，非常快捷方便，但是由于我个人的原因，开发起来还不是很熟练，最近买了O&#39;reilly的《Clojure编程》打算系统地学习一下clojure。另外一个感觉是clojure的文档有些地方对于我来说不是很好用，比如clojure 1.4里面很多包名都从contrib里面移出去了，我找这方面的文档找了半天还是没找到（以前找到过一次貌似，但是寒假里没找到），还有就是clojure的错误信息有些时候很难读懂，这个可能跟经验有关，以后再慢慢积累吧。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
